package baekjoon;

import java.util.Scanner;

/**
 * 1로 만들기
 *
 * 1. 문제 정리
 * 	1-1. x 가 3으로 나누어 떨어지면 3으로 나눈다.
 * 	1-2. x 가 2로 나누어 떨어지면 2로 나눈다.
 * 	1-3. 1을 뺀다.
 * 	1-4. 위 연산을 최소로 사용해 1을 만들어라.
 *
 * 2. dp[i]
 * 	2-1. i: 만들어진 숫자, dp[i] = 횟수
 * 	2-2. dp[1] = 0, dp[2] = 1, dp[3] = 1 로 초기화 한다.
 * 	2-3. 3으로 나누어떨어지지만 2로는 안되는 경우
 * 		2-3-1. 3으로 나눈 값 + 1 vs 1 뺀값 + 1
 * 	2-4. 2로 나누어떨어지지만 3으로 나느 안되는 경우
 * 		2-4-1. 2로 나눈 값 + 1 vs 1 뺀값  + 1
 * 	2-5. 둘다 나누어 떨어지는 경우
 * 		2-5-1. 3으로 나눈값 + 1 vs 2로 나눈 값 + 1
 * 	2-6. 다 아닌 경우 1 뺀값 + 1
 */
public class M1463 {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int N = scan.nextInt();
        // 2-1. i: 만들어진 숫자, dp[i] = 횟수
        int[] dp = new int[N + 1];

        // 2-2. dp[1] = 0, dp[2] = 1, dp[3] = 1 로 초기화 한다.
        dp[1] = 0;
        if (N >= 2)
            dp[2] = 1;
        if (N >= 3)
            dp[3] = 1;


        for (int i = 4; i <= N; i++) {
            if (i % 3 == 0 && i % 2 != 0)
                // 2-3. 3으로 나누어떨어지지만 2로는 안되는 경우
                // 2-3-1. 3으로 나눈 값 + 1 vs 1 뺀값 + 1
                dp[i] = Math.min(dp[i / 3] + 1, dp[i - 1] + 1);
            else if (i % 2 == 0 && i % 3 != 0)
                // 2-4. 2로 나누어떨어지지만 3으로 나느 안되는 경우
                // 2-4-1. 2로 나눈 값 + 1 vs 1 뺀값  + 1
                dp[i] = Math.min(dp[i / 2] + 1, dp[i - 1] + 1);
            else if (i % 2 == 0 && i % 3 == 0)
                // 2-5. 둘다 나누어 떨어지는 경우
                // 2-5-1. 3으로 나눈값 + 1 vs 2로 나눈 값 + 1
                dp[i] = Math.min(dp[i / 2] + 1, dp[i / 3] + 1);
            else
                // 2-6. 다 아닌 경우 1 뺀값 + 1
                dp[i] = dp[i - 1] + 1;
        }
        System.out.println(dp[N]);
    }
}